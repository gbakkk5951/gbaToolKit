【壹】
散列算法
  一、除法散列法：
  h(k)=k%m  （m是散列表的大小）
  ①m不应为2的幂，除非已知各种最低P位的排列形式是等可能的。
  ②一个不太接近2^n的素数通常是m的一个较好的选择。
  二、乘法散列法
  h(x)=floor（m * fmod( k*A ,1 )）//fmod( k*A ,1 )是取小数部分
  对m的选择不是很关键，一般选择它为2^n。
  A≈(sqrt（5）-1)/2=0.6180339887
  三、全域散列函数
  p为一个足够大的素数
  a∈[1,p-1]， b∈[0,p-1]
  a、b为静态随机变量，不是每次插入、查找时随机，而是创建时随机。
  hab=(（ak+b）%p)%m
【贰】
开放寻址法
一、函数
HASH_search(T,k)
{
i=0
do{
  j=h(k,i)
  if（T[j]==k）
  return j
  i++
  }
while(i!=m&&T[j]!=NULL);
return NULL
}

//////////////////////////
HASH_insert(T,k){
i=0
do{
  j=h(k,j) 
  if(T[j]==NULL){
    T[j]=k;
    return j;
    }
  i++
  }
while(i<m);
return NULL;
}
□□□□□□□□□□□□□
二、探查
h':U={0,1,2,3,…，m-1}  辅助散列函数
①线性探查
h(k,i)=(h'(k)+i)%m
存在一次群集的问题
②二次探查
h（h，i）= （h'（k）+c[1]*i+c[2]*i^2）%m
存在二次群集的问题
  c1和c2是辅助常量
③双重散列【开放寻址最佳】
h(k,i)=(h[1](k)+i*h[2](k))% m
h[2]（k）必须与m互素
如m=2^n，h[2](k)为奇数;  
※或m为素数，h【2】返回比m小的整数
{/////////////
h[1]（k）=k%m
h[2](k)=1+(k%m')
m'为一个略小于m的数
如m’=m-1
}/////////////
【叁】
完全散列

二次散列表（sencondary hash table）
两层全域散列
总体空间复杂度Θ（n）

每一个外层槽有n^2个内层槽
